// GatOutput.cpp: implementation of the GatOutput class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"



//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

GatOutput::GatOutput(GATenv * e, HierarchialController * c)
{
	env = e;
	controller = c;

}

GatOutput::~GatOutput()
{

}


void GatOutput::outputGatFiles(char * idHeader)
{
	///Compose the name of the file
	char * filename = new char[NUMCOLUMNS]; 
	sprintf(filename, "%s-output.GAT", idHeader);

	///Define the output file.
	currentOutputFile = fopen(filename, "w");
	//currentOutputFile = new ofstream(filename);

	///print out the remarks and global info
	printGlobals();

	///print out the source protein stuff
	printSourceProtein();

	///print out the target molecule
	printTargetMol();

	///print out the match arrays
	printMatchArray();

	///print out the RMSDs
	printINFOArray();

	///Close the file
	//(*currentOutputFile).close();
	fclose(currentOutputFile);
}

void GatOutput::outputPartialGatFiles(char * idHeader)
{
	///Compose the name of the file
	char * filename = new char[NUMCOLUMNS]; 
	sprintf(filename, "%s-output.GAT", idHeader);

	///Define the output file.
	//currentOutputFile = new ofstream(filename);
	currentOutputFile = fopen(filename, "w");

	///print out the remarks and global info
	printGlobals();

	///print out the source protein stuff
	printSourceProtein();

	///print out the target molecule
	printTargetMol();

	///Close the file
	//(*currentOutputFile).close();
	fclose(currentOutputFile);
}

void GatOutput::outputXGatFiles(char * idHeader)
{
	///Compose the name of the file
	char * filename = new char[NUMCOLUMNS]; 
	sprintf(filename, "%s-output.XGAT", idHeader);

	///Define the output file.
	//currentOutputFile = new ofstream(filename);
	currentOutputFile = fopen(filename, "w");

	///print out the remarks and global info
	printGlobals();

	///print out the source protein stuff
	printSourceProtein();

	///print out the target molecule
	printTargetMol();


	///print out the HIERARCHIAL match arrays
	printXGatMatchArray();

	///print out the HIERARCHIAL RMSDs/INFO
	printXGatINFOArray();

	///Close the file
	//(*currentOutputFile).close();
	fclose(currentOutputFile);

}




//////
///Prints out global information for the file, including comments
void GatOutput::printGlobals(){
	caList * alist;
	char * tempString = new char[NUMCOLUMNS];

	sprintf(tempString, "##SOURCE:");
	alist = env->sourceList;
	sprintf(tempString, "%s %s", tempString, alist->name);

	sprintf(tempString, "%s\n", tempString);

	fprintf(currentOutputFile, "#######################################################################\n");
	fprintf(currentOutputFile, "##This GAT file generated by Protein Geometric Hashing, by Brian Chen##\n");
	fprintf(currentOutputFile, "#######################################################################\n");
	fprintf(currentOutputFile, "#######################################################################\n");
	
	fprintf(currentOutputFile, "##TARGET: %s\n", env->targetList->name);

	fprintf(currentOutputFile, "##QueryThreshold: USE MATCHXPANDER SETTINGS\n");

	fprintf(currentOutputFile, "##MatchThreshold: USE MATCHXPANDER SETTINGS\n");

	fprintf(currentOutputFile, "##\n");

	////note if this is an atom level experiment, or a regular C-alpha one
	fprintf(currentOutputFile, "##\n");
	fprintf(currentOutputFile, "#######################################################################\n");

	fprintf(currentOutputFile, "NUMSOURCES= 1\n");

	fprintf(currentOutputFile, "NUMARRAYS= %i\n\n", env->numArrays);
}




//////
///Prints out the segment of the file corresponding to one particular source protien file
void GatOutput::printSourceProtein(){
	caList * alist = env->sourceList;
	aminoAcid * tempAcid;
	PdbAtom * tempAtom;
	bool onlyCA = true;
	char * tempString = new char[NUMCOLUMNS];
	int i = 0;
	int k = 0;

	bool firstTime;	////firsTime is false if we have already appended onto aaIntro or aabody

	fprintf(currentOutputFile, "SOURCE 1 %s\n", alist->name);

	/////////////////////////////////////////////////////////////////
	///FOR AMINO ACID (C-A) PROCESSING WE DO THIS////////////////////
	/////////////////////////////////////////////////////////////////
	///Step through the motif once
	for (i = 0; i<alist->numAcids; i++){
		char *aaBody = new char[30*NUMCOLUMNS];
		firstTime = true;
		onlyCA = true;

		tempAcid = alist->acids[i];
		for(k = 0; k<tempAcid->numAtoms; k++){
			tempAtom = tempAcid->atoms[k];
			if(k == 0){
				sprintf(tempString, "          ATOM %lf %lf %lf %i %s %s %i %s\n",
					tempAtom->coords[0], tempAtom->coords[1], tempAtom->coords[2], 
					tempAtom->significance, tempAtom->atom_name, tempAtom->residue_name, 
					tempAtom->residue_number, tempAcid->assocArray);
				strcpy(aaBody, tempString);				
			}
			else{
				sprintf(tempString, "          ATOM %lf %lf %lf %i %s %s %i %s\n",
					tempAtom->coords[0], tempAtom->coords[1], tempAtom->coords[2], 
					tempAtom->significance, tempAtom->atom_name, tempAtom->residue_name,
					tempAtom->residue_number, tempAcid->assocArray);
				strcat(aaBody, tempString);
			}
		}

		/////////////////////////////////////////////////////////////////
		///now print the lines into the file/////////////////////////////
		/////////////////////////////////////////////////////////////////
		if(tempAcid->numAtoms > 0){
			fprintf(currentOutputFile, aaBody);
		}

		delete[](aaBody);
	}

	/////////////////////////////////////////////////////////////////
	///Now we process Unselected Atoms///////////////////////////////
	/////////////////////////////////////////////////////////////////

	fprintf(currentOutputFile, "     UNSELECTED\n");

	/////////////////////////////////////////////////////////////////
	///This is where we process Amino Acid (C-A) Unselected motifs///
	/////////////////////////////////////////////////////////////////
	for (i = 0; i<alist->bag->numAtoms; i++){
//		char * aaBody = new char[30*NUMCOLUMNS];
		tempAtom = alist->bag->atoms[i];

		//add the atom in UNSELECTED
		fprintf(currentOutputFile, "          ATOM %lf %lf %lf %i %s %s %i\n", 
			tempAtom->coords[0], tempAtom->coords[1], tempAtom->coords[2], 
			tempAtom->significance, tempAtom->atom_name, tempAtom->residue_name,
			tempAtom->residue_number);
			///we dont print AssocAA's for bag atoms, because we never got any
//		delete[](aaBody);
	}

	/////////////////////////////////////////////////////////////////
	///Finish the Source Part of the File////////////////////////////
	/////////////////////////////////////////////////////////////////
	fprintf(currentOutputFile , "ENDSOURCE 1\n");
}


//////
///Prints out the segment of the file corresponding to the target
void GatOutput::printTargetMol(){
	char * tempString = new char[NUMCOLUMNS];
	caList * alist = env->targetList;
	PdbAtom * tempAtom;
	aminoAcid * tempAcid;
	int i = 0;
	int k = 0;
	bool firstTime;	////firsTime is false if we have already appended onto aaIntro or aabody
	bool allCAs;

	fprintf(currentOutputFile , "TARGET %s\n", env->targetList->name);

	/////////////////////////////////////////////////////////////////
	///FOR AMINO ACID (C-A) PROCESSING WE DO THIS////////////////////
	/////////////////////////////////////////////////////////////////
	///Step through the motif once
	for (i = 0; i<alist->numAcids; i++){
		char *aaBody = new char[30*NUMCOLUMNS];
		firstTime = true;
		allCAs = true;

		tempAcid = alist->acids[i];		
		for(k = 0; k<tempAcid->numAtoms; k++){
			tempAtom = tempAcid->atoms[k];
			if(k == 0){
				sprintf(tempString, "          ATOM %lf %lf %lf %i %s %s %i\n",
					tempAtom->coords[0], tempAtom->coords[1], tempAtom->coords[2], 
					tempAtom->significance, tempAtom->atom_name, tempAtom->residue_name,
					tempAtom->residue_number);
				strcpy(aaBody, tempString);				
			}
			else{
				sprintf(tempString, "          ATOM %lf %lf %lf %i %s %s %i\n",
					tempAtom->coords[0], tempAtom->coords[1], tempAtom->coords[2], 
					tempAtom->significance, tempAtom->atom_name, tempAtom->residue_name,
					tempAtom->residue_number);
				strcat(aaBody, tempString);
			}
		}


		/////////////////////////////////////////////////////////////////
		///now print the lines into the file/////////////////////////////
		/////////////////////////////////////////////////////////////////
		if(tempAcid->numAtoms > 0){
			fprintf(currentOutputFile, aaBody);
		}

		delete[](aaBody);
	}

	/////////////////////////////////////////////////////////////////
	///Now we processes the Unselected Atoms/////////////////////////
	/////////////////////////////////////////////////////////////////

	fprintf(currentOutputFile, "     UNSELECTED\n");

	/////////////////////////////////////////////////////////////////
	///Now we process Unselected Atoms For AMINO ACID (C-A) motifs///
	/////////////////////////////////////////////////////////////////
	for (i = 0; i<alist->bag->numAtoms; i++){
		tempAtom = alist->bag->atoms[i];

		//add the atom in UNSELECTED
		fprintf(currentOutputFile, "          ATOM %lf %lf %lf %i %s %s %i\n", 
			tempAtom->coords[0], tempAtom->coords[1], tempAtom->coords[2], 
			tempAtom->significance, tempAtom->atom_name, tempAtom->residue_name,
			tempAtom->residue_number);
	}

	/////////////////////////////////////////////////////////////////
	///Now we process Unselected Atoms For AMINO ACID (C-A) motifs///
	/////////////////////////////////////////////////////////////////
	fprintf(currentOutputFile , "ENDTARGET\n");

}


//////
///Prints out the segment of the file corresponding to the ith Match Array
void GatOutput::printMatchArray(){
	int i = 0;
	int j = 0;
	int maxSize = 0;
	///find out the size of the largest match array
	for (i = 0; i<(env->numArrays); i++){
		if (env->matchArraySizes[i] > maxSize){
			maxSize = env->matchArraySizes[i];
		}
	}
	char * tempString = new char[maxSize*NUMCOLUMNS + NUMCOLUMNS];
	char * tempString2 = new char[NUMCOLUMNS];

	///Head the match Array set, and say all the sizes
	sprintf(tempString, "MATCHARRAYSIZES");
	for (i = 0; i<env->numArrays; i++){
		sprintf(tempString2, " %i", env->matchArraySizes[i]);
		strcat(tempString, tempString2);
	}
	strcat(tempString, "\n");
	fprintf(currentOutputFile, tempString);	

	///Now go through each array and give all the matchups
	for( i = 0; i<env->numArrays; i++){
		sprintf(tempString, "     MATCH");
		for (j = 0; j<env->matchArraySizes[i]; j++){
			sprintf(tempString2, " %i", env->matchArray[env->numArrays+i][2*j]);
			strcat(tempString, tempString2);
			sprintf(tempString2, " %i |", env->matchArray[env->numArrays+i][2*j+1]);
			strcat(tempString, tempString2);
		}
		strcat(tempString, "\n");
		fprintf(currentOutputFile, tempString);	
	}

	fprintf( currentOutputFile, "ENDMATCHARRAY\n");

////////////////////////////////////////////////////
////FIXME: Strange memory issue appears to occur with deleting tempString
////	for some input (in particular on the case with no matches), in windows.  This occurs at the end of execution and
///		is not called so often, so we leak it.
////////////////////////////////////////////////////

	delete[](tempString);
	delete[](tempString2);
}


void GatOutput::printINFOArray()
{
	int i = 0;
	char * tempString = new char[env->numArrays*NUMCOLUMNS*5];
	char * tempString2 = new char[NUMCOLUMNS];

	///Head the INFO Array set
	fprintf(currentOutputFile, "INFO ARRAYS\n");

	///Now go through each position in the array and give all the RMSD values
	for( i = 0; i<env->numArrays; i++){
		sprintf(tempString, "     MATCH %i:\n", i);
		if ( env->matchArraySizes[i] > 0 ){
			sprintf( tempString2, "          RMSD:     %lf \n", env->RMSDarray[env->numArrays + i] );
			strcat(tempString, tempString2);
			sprintf( tempString2, "          ROTATION: %lf %lf %lf \n                    %lf %lf %lf \n                    %lf %lf %lf \n", 
				env->rotArray[env->numArrays + i][0], env->rotArray[env->numArrays + i][3], env->rotArray[env->numArrays + i][6],  
				env->rotArray[env->numArrays + i][1], env->rotArray[env->numArrays + i][4], env->rotArray[env->numArrays + i][7],  
				env->rotArray[env->numArrays + i][2], env->rotArray[env->numArrays + i][5], env->rotArray[env->numArrays + i][8]  );
			strcat(tempString, tempString2);
			sprintf( tempString2, "          TRANS:    %lf %lf %lf \n", 
				env->transArray[env->numArrays + i][0], env->transArray[env->numArrays + i][1], env->transArray[env->numArrays + i][2]);
			strcat(tempString, tempString2);
		}
		fprintf(currentOutputFile, tempString);	
	}
	fprintf(currentOutputFile, "END INFO ARRAYS\n");

	delete[](tempString);
	delete[](tempString2);

}



//////
///Prints out the segment of the file corresponding to the ith Match Array
void GatOutput::printXGatMatchArray(){
	int i = 0;
	int j = 0;
	int maxSize = 0;
	TermList * tList = controller->term;
	AlignNode * currentAlign;

	///find out the size of the largest match array
	maxSize = env->sourceList->numAcids;
	
	char * tempString = new char[maxSize*NUMCOLUMNS + NUMCOLUMNS];
	char * tempString2 = new char[NUMCOLUMNS];

	///Head the match Array set, and say all the sizes
	sprintf(tempString, "MATCHARRAYSIZES");
	for (i = 0; i<tList->size; i++){
		currentAlign = tList->nodes[i];
		sprintf(tempString2, " %i", currentAlign->size);
		strcat(tempString, tempString2);
	}
	strcat(tempString, "\n");
	fprintf(currentOutputFile, tempString);	
	

	///Now go through each array and give all the matchups
	for( i = 0; i<tList->size; i++){
		sprintf(tempString, "     MATCH");
		currentAlign = tList->nodes[i];
		for (j = 0; j<currentAlign->size; j++){
			sprintf(tempString2, " %i", currentAlign->sourceIds[j]);
			strcat(tempString, tempString2);
			sprintf(tempString2, " %i |", currentAlign->targetIds[j]);
			strcat(tempString, tempString2);
		}
		strcat(tempString, "\n");
		fprintf(currentOutputFile, tempString);	
	}

	fprintf(currentOutputFile, "ENDMATCHARRAY\n");	

////////////////////////////////////////////////////
////FIXME: Strange memory issue appears to occur with deleting tempString
////	for some input (in particular on the case with no matches), in windows.  This occurs at the end of execution and
///		is not called so often, so we leak it.
////////////////////////////////////////////////////

	delete[](tempString);
	delete[](tempString2);
}


void GatOutput::printXGatINFOArray()
{
	int i = 0;
	char * tempString = new char[env->numArrays*NUMCOLUMNS*5];
	char * tempString2 = new char[NUMCOLUMNS*5];
	TermList * tList = controller->term;
	AlignNode * currentAlign;
	double * rot;
	double * trans;

	///Head the INFO Array set
	fprintf(currentOutputFile , "INFO ARRAYS\n");

	///Now go through each position in the array and give all the RMSD values
	for( i = 0; i<tList->size; i++){
		sprintf(tempString, "     MATCH %i:\n", i);
		currentAlign = tList->nodes[i];
		rot = currentAlign->getTotalRotation();
		trans = currentAlign->getTotalTranslation();

		sprintf( tempString2, "          RMSD:     %lf \n", currentAlign->RMSD);
		strcat(tempString, tempString2);
		sprintf( tempString2, "          ROTATION: %lf %lf %lf \n                    %lf %lf %lf \n                    %lf %lf %lf \n", 
			rot[0], rot[3], rot[6],  
			rot[1], rot[4], rot[7],  
			rot[2], rot[5], rot[8]  );
		strcat(tempString, tempString2);
		sprintf( tempString2, "          TRANS:    %lf %lf %lf \n", 
			trans[0], trans[1], trans[2]);
		strcat(tempString, tempString2);

		fprintf(currentOutputFile, tempString);	

		delete[](rot);
		delete[](trans);
	}
	fprintf(currentOutputFile, "END INFO ARRAYS\n");

////////////////////////////////////////////////////
////FIXME: Strange memory issue appears to occur with deleting tempString
////	for some input (in particular on the case with no matches), in windows.  This occurs at the end of execution and
///		is not called so often, so we leak it.
////////////////////////////////////////////////////

//	delete[](tempString);
	delete[](tempString2);

}


