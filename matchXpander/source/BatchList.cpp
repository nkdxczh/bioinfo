// BatchList.cpp: implementation of the BatchList class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

BatchList::BatchList(char * fname, Motif * m)
{

	size = 0;
	currentFile = 0;
	fileList = NULL;
	motif = m;

	file = fopen(fname, "r");					//Open File

	if(file == NULL){
		printf("ERROR: File %s does not exist\n", fname);
		exit(1);
	}

	parse();

	expList = new char*[size];
	matchSizes = new char*[size];
	matchRMSDs = new char*[size];
	matchListings = new char*[size];

	sourceSize = 0;
	numMatchedPerfect = 0;
	avgPointsMatched = 0.0;
	avgMatchRMSD = 0.0;

	years = 0;
	days = 0;
	hours = 0;
	minutes = 0;
	seconds = 0;
	ms = 0;
	startTime = 0;
	endTime = 0;
}

BatchList::BatchList(Motif * m, int thisSize)
{

	size = thisSize;
	currentFile = 0;
	fileList = NULL;
	motif = m;

	fileList = new char*[size];
	for(int i = 0; i<size; i++){
		fileList[i] = new char[1];
	}

	expList = new char*[size];
	matchSizes = new char*[size];
	matchRMSDs = new char*[size];
	matchListings = new char*[size];

	sourceSize = 0;
	numMatchedPerfect = 0;
	avgPointsMatched = 0.0;
	avgMatchRMSD = 0.0;

	years = 0;
	days = 0;
	hours = 0;
	minutes = 0;
	seconds = 0;
	ms = 0;
	startTime = 0;
	endTime = 0;
}

BatchList::~BatchList()
{
	int i = 0;
	for(i = 0; i<size; i++){
		delete[](fileList[i]);
		delete[](expList[i]);
		delete[](matchSizes[i]);
		delete[](matchRMSDs[i]);
		delete[](matchListings[i]);
	}
	delete[](fileList);
	delete[](expList);
	delete[](matchSizes);
	delete[](matchRMSDs);
	delete[](matchListings);
}

void BatchList::parse()
{
	int i = 0;
	char *line = new char[NUMCOLUMNS];
	char *lineBuffer;
	char * firstCharacter;

	///skip comments
	fgets(line, NUMCOLUMNS, file);
	firstCharacter = firstChar(line);
	while( strcmp( firstCharacter, "#") == 0 ){
		fgets(line, NUMCOLUMNS, file);
		delete[](firstCharacter);
		firstCharacter = firstChar(line);
	}
	delete[](firstCharacter);

	lineBuffer = &line[0];					/////linebuffer points to line

	///Catch file violation
	if( strcmp(strtok(line, " ,\r\n"), "SIZE") == 0){
		size = atoi(strtok(NULL, " ,\r\n"));
	}
	else{
		printf("ERROR: expected SIZE line in BatchList\n");
		exit(1);
	}

	///init the array of filenames
	fileList = new char*[size];

	///Save all the filenames
	char * anotherTempString;
	for(i = 0; i<size; i++){
		fgets(line, NUMCOLUMNS, file);
		lineBuffer = &line[0];					/////linebuffer points to line
		anotherTempString = stringCopy(lineBuffer,0,strlen(line));
		fileList[i] = strtok(anotherTempString, " \r\n");	///these char *'s have newlines after them
	}

	delete[](line);
}

void BatchList::printOutMetaStats(char * fname)
{
	int i = 0, j = 0;
	int totalAtoms = 0;;

	///Define the output file.
	FILE * currentOutputFile = fopen(fname, "w");

	///print out the remarks and global info
	fprintf( currentOutputFile, "########################################################################\n");
	fprintf( currentOutputFile, "##   This META file generated by Match Augmentation,  by Brian Chen   ##\n");
	fprintf( currentOutputFile, "########################################################################\n");
	fprintf( currentOutputFile, "########################################################################\n");
	
	char * tempString = new char[NUMCOLUMNS];

	fprintf(currentOutputFile, "## MOTIF: \n");
	for(i = 0; i<motif->numResidues; i++){
		totalAtoms += motif->numAtoms[i];
		sprintf(tempString, "##    %s #%i, Rank %i, Side Chain Atoms: %s\n", motif->atoms[i][0]->residue_name, 
			motif->atoms[i][0]->residue_number, 
			motif->atoms[i][0]->significance,
			motif->atoms[i][0]->assocAA);
		fprintf(currentOutputFile, tempString);
		sprintf(tempString, "##        Atoms Used: ");
		for(j = 0; j<motif->numAtoms[i]; j++){
			sprintf(tempString, "%s %s,", tempString, motif->atoms[i][j]->atom_name);
		}
		fprintf(currentOutputFile, tempString);
		fprintf(currentOutputFile, "\n");
	}
	sprintf(tempString, "##\n");
	fprintf(currentOutputFile, tempString);

	sprintf(tempString, "##Source Motif Size: %i  Total Number of Atoms: %i\n", motif->numResidues, totalAtoms);
	fprintf(currentOutputFile, tempString);
	sprintf(tempString, "##Average Points Matched: %lf\n", avgPointsMatched);
	fprintf(currentOutputFile, tempString);
	sprintf(tempString, "##Average Match RMSD: %lf\n", avgMatchRMSD);
	fprintf(currentOutputFile, tempString);
	sprintf(tempString, "##Total Runtime: %li seconds\n", (endTime - startTime));
	fprintf(currentOutputFile, tempString);
	fprintf(currentOutputFile, "##\n");

	fprintf(currentOutputFile, "#######################################################################\n");
	fprintf(currentOutputFile, "Experiment   Matched/Total(target)   RMSD         Match\n");
	fprintf(currentOutputFile, "#######################################################################\n");

	///print out the match information
	for(i = 0; i<size; i++){
		if(matchSizes[i][0] != '0'){
			fprintf(currentOutputFile, "%s \t %s  \t %s \t %s\n", expList[i], matchSizes[i], matchRMSDs[i], matchListings[i]);
		}
		if(matchSizes[i][0] == '0'){
			fprintf(currentOutputFile, "%s \t\t %s  \t\t\t\t  N/A\n", expList[i], matchSizes[i]);
		}
	}

	///Close the file
	fclose(currentOutputFile);

	delete[](tempString);
	delete(currentOutputFile);
}


bool BatchList::finished()
{
	if( currentFile >= size ){
		return true;
	}

	return false;
}

char * BatchList::getNextFile()
{
	char * result;
	if(finished()){
		printf("ERROR: YOU DIDNT CHECK TO SEE IF THERE WERE ANY FILES LEFT\n");
	}

	result = fileList[currentFile];
	currentFile++;

	return result;
}


void BatchList::beginTime(long val)
{
	this->startTime = val;
}


void BatchList::updateTime(long val)
{
	this->endTime = val;

	long elapsed = endTime - startTime;

	int newseconds = (int) (elapsed/CLOCKS_PER_SEC);

	int newyears = newseconds/(86400*365);
	int newdays = (newseconds % (86400*365))/86400;
	int newhours = (newseconds % 86400)/3600;
	int newmins = (newseconds % 3600)/60;
	int newsecs = newseconds % 60;
	int newms = (int) ( (long) elapsed % (CLOCKS_PER_SEC/1000) );
	
	int carry = 0;
	ms += newms;
	if(ms > 1000){
		carry = (int) (ms/1000);
		ms = ms % 1000;
	}
	seconds = seconds + carry + newsecs;
	if(seconds > 60){
		carry = (int) (seconds/60);
		seconds = seconds % 60;
	}
	minutes = minutes + carry + newmins;
	if(minutes > 60){
		carry = (int) (minutes/60);
		minutes = minutes % 60;
	}
	hours = hours + carry + newhours;
	if(hours > 24){
		carry = (int) (hours/24);
		hours = hours % 24;
	}
	days = days + carry + newdays;
	if(days > 365){
		carry = (int) (days/365);
		days = days % 365;
	}
	years = years + carry + newyears;

	startTime = endTime;
}


void BatchList::printTime()
{
	printf("Elapsed Time: %i years, %i days, %i hours, %i mins, %i s, %i ms\n", years, days, hours, minutes, seconds, ms);	

	int mins = years*365*24*60 + days*24*60 + hours*60 + minutes;

	printf("Elapsed Time: %i mins, %i s, %i ms\n", mins, seconds, ms);	
}





